/**
 * UIBakery Data Package
 *
 * This package provides data hooks and utilities for UIBakery applications.
 */
/**
 * Hook for accessing data in UIBakery applications.
 *
 * This hook allows components to access shared data properties by their name.
 * It can be used to retrieve values from the application's data store.
 *
 * @param {string} prop - The name of the property to access
 * @param {any} [propDefault] - Optional default value to return if the property doesn't exist
 * @returns {any} The value of the requested property or the default value if not found
 *
 * @example
 * // Get a string value with a default
 * const username = useData('user.name', 'Guest');
 *
 * // Get a complex object
 * const userSettings = useData('settings');
 */
export declare function useData(prop: string, propDefault?: any): any;
/**
 * Hook for loading data through actions in UIBakery applications.
 *
 * This hook executes a named action to load a list of records and provides loading state management.
 * It automatically handles loading states, errors, and provides a way to reload the data.
 *
 * @param {ActionFactory | string} actionName - The name or factory of the action to execute
 * @param {any} [defaultValue] - Optional default value for each item before data is loaded; the returned data will default to an empty array if omitted
 * @param {any} [params] - Optional parameters to pass to the action
 * @returns {[any, boolean, Error | null, () => Promise<void>]} A tuple containing:
 *   - An array of loaded records, or an empty/default array or object
 *   - A boolean indicating whether the action is currently loading
 *   - An Error object if the action failed, or null if successful/loading
 *   - A function to manually trigger the action again (reload)
 *
 * @example
 * // Load a list of users
 * const [users, isLoading, error, reload] = useLoadAction(getUsersAction, [], {});
 *
 * @example
 * // Load a single user wrapped in an array, and extract the first record
 * const [result, isLoading] = useLoadAction(getUserByIdAction, [], { id: 1 });
 * const user = result[0] ?? null;
 */
export declare function useLoadAction(actionName: ActionFactory | string, defaultValue?: any[], params?: any): [any, boolean, Error | null, () => Promise<void>];
/**
 * Hook for performing data mutations in UIBakery applications.
 *
 * This hook provides a function to execute a named mutation action and tracks its loading and error states.
 * It's typically used for create, update, or delete operations that modify data.
 *
 * @param {string} actionName - The name of the mutation action to execute
 * @returns {[(params?: any) => Promise<unknown>, boolean, Error | null]} A tuple containing:
 *   - A function that executes the mutation when called with optional parameters
 *   - A boolean indicating if the mutation is currently in progress
 *   - An Error object if the mutation failed, or null if successful/in progress
 *
 * @example
 * // Create a mutation hook for updating a user
 * const [updateUser, isUpdating, updateError] = useMutateAction('updateUser');
 *
 * // Use the mutation function with parameters
 * const handleSubmit = async () => {
 *   try {
 *     await updateUser({ id: 123, name: 'New Name' });
 *     // Handle success
 *   } catch (error) {
 *     // Handle error
 *   }
 * };
 */
export declare function useMutateAction(actionName: ActionFactory | string): [(params?: any) => Promise<any>, boolean, Error | null];
/**
 * Triggers an event in UIBakery applications.
 *
 * This function allows components to trigger named events that can be listened to by other parts of the application.
 * It's commonly used for cross-component communication or to trigger workflows.
 *
 * @param {any} [param] - Optional parameters to include with the triggered event
 * @returns {void} This function doesn't return a value
 *
 * @example
 * // Trigger a simple event without parameters
 * triggerEvent();
 *
 * // Trigger an event with parameters
 * triggerEvent({ action: 'itemSelected', itemId: 123 });
 *
 */
export declare function triggerEvent(param?: any): void;
export interface SqlActionSettings {
    databaseName: string;
    query: string;
}
export interface MongoActionSettings {
    databaseName: string;
    command: string;
}
export interface HttpActionSettings {
    datasourceName: string;
    options: {
        method: 'GET' | 'POST' | 'DELETE' | 'PUT' | 'HEAD' | 'OPTIONS' | 'PATCH';
        url: string;
        queryParams?: Record<string, string> | string;
        headers?: Record<string, string> | string;
        bodyType?: 'raw' | 'object' | 'formData' | 'formUrlEncoded' | 'binary';
        body?: string;
    };
}
export type ActionSettings = (SqlActionSettings | MongoActionSettings | HttpActionSettings) & {
    databaseName?: string;
    datasourceName?: string;
};
export type ActionType = 'SQL' | 'MongoDB' | 'HTTP';
export type ActionConfig = {
    name: string;
    type: ActionType;
    config: ActionSettings;
};
export type ActionFactory = () => ActionConfig;
export declare function action(name: string, type: 'SQL', config: SqlActionSettings): ActionConfig;
export declare function action(name: string, type: 'MongoDB', config: MongoActionSettings): ActionConfig;
export declare function action(name: string, type: 'HTTP', config: HttpActionSettings): ActionConfig;
//# sourceMappingURL=index.d.ts.map